---
layout: post
tags: [가리사니, 기타]
---

> 이 문서는 가리사니 개발자 포럼에 올렸던 글의 백업 파일입니다.
오래된 문서가 많아 현재 상황과 맞지 않을 수 있습니다.



이글은 CC BY-NC-SA 3.0 로 작성된 문서를 퍼왔습니다. [출처는 아래와 같음]
http://terzeron.net/wiki/doku.php?id=%EB%B2%88%EC%97%AD_php_%EC%BD%94%EB%93%9C%EB%A5%BC_%EC%B5%9C%EC%A0%81%ED%99%94%ED%95%98%EB%8A%94_40%EA%B0%80%EC%A7%80_%ED%8C%81


원문: Reinhold Weber씨의 40 Tips for optimizing your php Code
원문주소 : http://reinholdweber.com/?p=3

1. 메쏘드가 static이 될 수 있다면 static으로 선언하라. 4배 빨라진다.
2. echo가 print보다 빠르다.
3. 문자열을 이어붙이지 말고, echo를 이용하여 여러 개의 파라미터를 적어라.
4. for 루프을 위핸 최대값(탈출조건)을 루프 안에서가 아니고 루프 시작 이전에 지정하라.
5. 메모리를 해제하기 위해 변수를 unset하라. 특히 커다란 배열은 그래야 된다.
6. get, set, __autoload와 같은 마법을 피해라.
7. require_once()는 비싸다.
8. include와 require를 사용할 때, 경로를 찾는데 시간이 적게 걸리는 full path를 사용하라.
9. 스크립트가 언제 실행했는지 알고 싶으면 time()보다 $_SERVER['REQUEST_TIME']이 좋다.
10. 정규표현식보다는 가능하면 strncasecmp나 strpbrk, stripos를 사용하라.
  역주
   strncasecmp: 두 문자열의 앞쪽 일부가 대소문자 구분없이 일치하는지 확인할 때 사용
   strpbrk: 문자 집합에 속한 특정 문자가 문자열에 나타나는지 확인할 때 사용
   stripos: 대소문자 구분없이 특정 문자열이 다른 문자열에 포함되는지 확인할 때 사용
11. str_replace가 preg_replace보다 빠르지만, strtr은 str_replace보다 4배 빠르다.
12. 만약 문자열 교체 같은 함수가 배열과 문자열을 인자로 받아들이면, 그리고 그 인자 리스트가 길지 않다면, 배열을 한 번에 받아들여서 처리하는 것 대신에 한 번에 문자열을 하나씩 넘겨서 처리하는 것을 고려해봐라.
13. 여러 개의 if/else if 문장 대신에 select 문장을 사용하는 게 더 좋다.
14. @를 이용한 에러 출력 방지는 매우 느리다.
15. Apache의 mod_deflate를 켜라.
  역주
   mod_deflate는 서버의 출력을 클라이언트에게 보내기 전에 압축하는 모듈임
16. DB를 다 사용했으면 연결을 닫아라.
17. $row['id']가 $row[id]보다 7배 빠르다.
18. 에러 메시지는 비싸다.
19. for 루프의 표현식 안에서 함수를 사용하지 마라. for ($x = 0; $x < count($array); $x)에서 count() 함수가 매번 호출된다.
20. 메쏘드 안에서 지역 변수를 증가시키는 것이 거의 함수 안에서 지역 변수를 호출(증가?)하는 것만큼 빠르다.
21. 전역 변수를 증가시키는 것이 지역 변수를 증가시키는 것보다 2배 느리다.
22. 객체의 멤버변수를 증가시키는 것이 지역 변수를 증가시키는 것보다 3배 느리다.
23. 값이 지정되지 않은 지역 변수를 증가시키는 것이 미리 초기화된 변수를 증가시키는 것보다 9~10배 느리다.
24. 전역 변수를 함수 안에서 사용하지 않으면서 그저 선언하기만 해도 (지역 변수를 증가시키는 것만큼) 느려진다. PHP는 아마 전역 변수가 존재하는지 알기 위해 검사를 하는 것 같다.
25. 메쏘드 호출은 클래스 안에서 정의된 메쏘드의 갯수에 독립적인 듯 하다. 왜냐하면 10개의 메쏘드를 테스트 클래스에 추가해봤으나 성능에 변화가 없었기 때문이다.
26. 파생된 클래스의 메쏘드가 베이스 클래스에서 정의된 것보다 더 빠르게 동작한다.
27. 한 개의 매개변수를 가지고 함수를 호출하고 함수 바디가 비어있다면(함수 내부에서 아무것도 실행하지 않는다면) 그것은 7~8개의 지역변수를 증가시키는 것과 똑같은 시간을 차지한다. 비슷한 메쏘드 호출은 마찬가지로 15개의 지역변수를 증가시키는 연산쯤 된다.
28. 문자열을 이중 따옴표 대신에 단일 따옴표로 둘러싸는 것은 좀 더 빠르게 해석되도록 한다. 왜냐하면 PHP가 이중 따옴표 안의 변수를 찾아보지만 단일 따옴표 안에서는 변수를 찾지 않기 때문이다. 물론 문자열 안에서 변수를 가질 필요가 없을 때만 이렇게 사용할 수 있다.
29. 문자열을 echo할 때 마침표 대신에 쉼표로 분리하는 것이 더 빠르다.
30. 주의: 이것은 여러 문자열을 인자로 받아들이는 함수인 echo로만 작동한다.
31. Apache에 의해 PHP 스크립트는 정적 HTML 페이지보다 최소 2에서 10배 느리게 서비스된다. 더 많은 정적 HTML 페이지와 더 적은 스크립트를 사용하려고 노력하라.
32. PHP 스크립트는 캐시되지 않으면 매번 재 컴파일된다. 컴파일 시간을 제거함으로써 25~100%만큼의 성능을 증가시키기 위해 PHP 캐싱 도구를 설치하라.
33. 가능한 한 많이 캐시하라. memcached를 사용하라. memcached는 고성능 메모리 객체 캐싱 시스템이다.
34. 문자열을 가지고 작업하며 문자열이 특정 길이인지 확인할 필요가 있을 때, strlen() 함수를 쓸 것이다. 이 함수는 계산없이 zval 구조체에서 사용할 수 있는 이미 알려진 문자열 길이를 반환하기 때문에 매우 빠르다. 그러나 strlen()이 함수이기 때문에 여전히 조금 느리다. 왜냐하면 함수 호출은 언급된 함수의 실행 뒤에 lowercase와 hashtable lookup같은 여러 개의 연산을 호출하기 때문이다. 어떤 경우에는 isset() 트릭을 이용하여 코드의 스피드를 증가시킬 수도 있다.
``` java
if (strlen($foo) < 5) { echo "Foo is too short"; }
if (!isset($foo{5})) { echo "Foo is too short"; }
```
  - isset()을 호출하는 것은 strlen()과는 달리 isset()이 언어 기본문법이고 함수가 아니기 때문에 함수 찾와 lowercase 작업을 필요로 하지 않으므로 strlen()보다 더 빠를 수도 있다. 이것은 가상적으로 문자열의 길이를 결정하는 실제 코드에 과부하가 없다는 것을 의미한다.
35. 변수 $i의 값을 증가시키거나 감소키킬 때, $i++은 ++$i보다 조금 더 느릴 수 있다. 이것은 PHP의 특징이고 다른 언어에는 해당되지 않으니 좀 더 빨라질 것을 기대하면서 C나 Java 코드를 바꾸러 가지 마라. 안 빨라질 것이다. ++$i는 PHP에서 좀 더 빠른데 그것은 $i++에 4개의 opcode가 사용되는 대신에 3개만 필요하기 때문이다. 후증가는 사실 증가될 임시변수의 생성을 초래한다. 반면에 전증가는 원래 값을 직접 증가시킨다. 이것은 opcode가 Zend의 PHP optimizer처럼 최적화하는 최적화 기법의 하나이다. 모든 opcode optimizer들이 이 최적화를 수행하는 것은 아니고 많은 ISP와 server들이 opcode optimizer없이 수행되고 있기 때문에 명심하는 게 좋을 것이다.
36. 모든 것이 OOP일 필요는 없다. 종종 그것은 너무 많은 과부하가 된다. 각각의 메쏘드와 객체 호출은 메모리를 많이 소비한다.
37. 모든 데이터 구조를 클래스로 구현하지 마라. 배열도 유용하다.
38. 메쏘드를 너무 많이 분리하지 마라. 어떤 코드를 정말 재사용할지 생각해봐라.
39. 항상 메쏘드의 코드를 나중에 필요할 때 분리할 수 있다.
40. 수많은 미리 정의된 함수를 활용해라.
41. 매우 시간을 소비하는 함수가 있다면, C 확장으로 작성하는 것을 고려해봐라.
42. 당신의 코드를 프로파일해봐라. 프로파일러는 코드의 어떤 부분이 가장 많은 시간을 소비하는지 보여준다. Xdebug 디버거는 이미 프로파일러를 포함하고 있다. 프로파일링은 전체적인 병목을 보여준다.
43. Apache 모듈로 사용가능한 mod_gzip은 실행 중에 데이터를 압축하여 전송할 데이터를 80%까지 줄일 수 있다.
44. John Lim의 PHP를 최적화하는 것에 관한 뛰어난 글 [ http://phplens.com/lens/php-book/optimizing-debugging-php.php ]