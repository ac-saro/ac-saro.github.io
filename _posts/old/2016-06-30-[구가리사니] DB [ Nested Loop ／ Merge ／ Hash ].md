---
layout: post
tags: [가리사니, 기타]
---

> 이 문서는 예전 가리사니 사이트에서 작성된 문서 입니다.
현재 상황과 맞지 않을 수 있습니다.


**rows [A]가 rows [B]를 조인**한다고 가정하고 설명.


# Nested Loop Join
작동방법
``` java
반복 (rows [A])
{
	반복 (rows [B])
	{
		매칭되는 결과를 조인
	}
}
```
rows [A] 에서 rows [B]에 해당하는 결과를 순차적으로 찾는다.
예를들어 rows [A] 8개이고 rows [B]가 10개라고한다면,
매칭되는 결과를 조인시킴
매칭확인 : [A] row 1 == [B] row 1
매칭확인 : [A] row 1 == [B] row 2
...
매칭확인 : [A] row 1 == [B] row 10
매칭확인 : [A] row 2 == [B] row 1
...
매칭확인 : [A] row 8 == [B] row 10
이렇게 순차적으로 총 80번의 매칭을 하여 결과를 표현한다.
설명
- 순차적인 진행
- 선행 테이블 (여기서는 rows A) 의 처리 범위가 처리속도를 좌우한다.
- 후행 테이블은 선행조건을 가지고 계산됩니다.
- 즉 후행 테이블은 미리 조건을 필터 한 후 선행으로 다시 필터하여 조인을 해야합니다.
- 엑세스할 데이터가 적을 때 더 높은 성능을 발휘한다.
장점
- 처리 방향성을 갖는다.
- 부분 범위를 처리한다.
단점
- 랜덤 IO를 많이 소모함.
- 선행/후행 테이블을 필터하는 과정에서 인덱스가 없을 경우 풀스켄을 하게된다.


# Sort Merge Join
작동방법
``` java
정렬(rows [A])
정렬(rows [B])
반복 (rows [A] 끝 혹은 rows [B] 끝)
{
	if (rows [A].현재키 == rows [B].현재키)
	{
		최종출력에 추가
		rows [A] -> 다음 키 위치로
		rows [B] -> 다음 키 위치로
	}
	else if (rows [A].현재키 < rows [B].현재키)
	{
		rows [A] -> 다음 키 위치로
	}
	else
	{
		rows [B] -> 다음 키 위치로
	}
}
```
rows [A]와 rows [B]의 매칭될 열을 정렬시킨다.
양쪽의 키를 비교하면서 정렬한다.
특징
- 디스크가 빠르고 CPU가 느린환경일수록 더 높은 성능을 발휘한다.
장점
- 대량처리에서 성능적 이점이 있다.
- 양쪽 테이블을 동시에 작업한다.
단점
- 정렬을 위해 메모리를 많이 사용하게 된다.
- 정렬에 클러스터 인덱스가 사용되지 않는경우 임시공간을 쓰며, 이 공간이 임계치를 초과한 경우 전체 DB성능에 문제가 생길 수 있다.


# Hash Join
작동방법
해시 버킷이라는 단위를 만든다.
해당 해시 버킷을 가지고 비교연산으로 매칭시킨다.
더 쉽게 설명하면 Java 의 HashMap 같은 것에 자주 사용되는 키를 등록해두고 매번 put 으로 꺼내 쓰는것 과 유사하다.
(자바의 HashMap도 key의 hashcode를 이용하여 찾는다.)
다만 DB의 해시코드는 데이터의 량을 따졌을때 겹칠 확률이 높음으로 해시 버킷이라는 단위가 쓰인다.
(즉 자바로 더 유사하게 구현한다면 HashMap<KEY, Array> 정도가 될 것 같다.)
특징
- Merge Join이 대량의 데이터를 디스크에 사용한다면 Hash Join은 소량의 데이터를 메모리에 사용한다.
- 디스크가 느리고 CPU가 빠른환경 일수록 더 높은 성능을 발휘한다.
장점
- 보조 기억으로 디스크가 아닌 메모리를 사용함으로 디스크 IO에 의한 높은 병목현상이 발생하지않는다.
단점
- 동등한 비교 조건에서만 사용할 수 있다.


# 동영상으로 한번에 보기! (57초부터)
@[Youtube o1dMJ6-CKzU]