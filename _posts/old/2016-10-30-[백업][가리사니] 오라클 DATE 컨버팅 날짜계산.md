---
layout: post
tags: [가리사니, 기타]
---

> 이 문서는 가리사니 개발자 포럼에 올렸던 글의 백업 파일입니다.
오래된 문서가 많아 현재 상황과 맞지 않을 수 있습니다.


# 현재 날짜
``` java
SELECT
	SYSDATE,
	SYSTIMESTAMP
FROM DUAL
```

# text로 변환
``` java
SELECT
	TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'),
	TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD HH24:MI:SS.FF9')
FROM DUAL
```
to_char 포멧
참고 : http://docs.oracle.com/cd/B19306_01/server.102/b14200/sql_elements004.htm#i34924
YYYY / YY : (연도)
잘 쓰이진 않을거 같지만 YYY / Y 같은 형태로 사용할 수도 있습니다.
예) 2016년 || YYYY -> 2016 || YYY -> 016 || YY -> 16 || Y -> 6
MM : (월)
마찬가지로 01~12 의 값을 반환합니다.
MON 과 MONTH 도 있지만 로컬라이징됨으로 한국어로 설정되어있다면 둘다 "10월" 입니다.
DD : (일)
01~31의 값입니다.
DDD 를 사용할 경우 1~366의 값을 같습니다.
HH / HH12 / HH24 : (시)
보통 hh가 12시간 HH가 24시간에 익숙하시다면 조심해야합니다.
HH는 12시간이며 HH24를 써야 24시간으로 나옵니다.
MI : (분)
일반적인 분입니다.
오라클을 비롯한 많은 DBMS는 MM월 mm분이 아닌 MI를 분으로 하는 경우가 많습니다.
SS : (초)
일반적으로 흔한 초입니다.
FF(숫자 1~9) : (초이하)
- 이 값은 SYSDATE 에서 쓸수없으며, SYSTIMESTAMP 에서 사용할 수 있습니다.
FF1 0.1초
FF2 0.01초
...
FF9 0.000000001초
예를들어 아래와 같이 썼을경우
``` java
SELECT
	TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD HH24:MI:SS.FF9')
FROM DUAL
```
2016-10-31 01:57:00.320000000 같은 값이 나오게 됩니다.
D / DAY : (요일)
DAY는 한국어일 경우 [일요일 ~ 토요일]이 나옵니다.
D는 특이하게 1~7의 값이 나오며 1은 일요일입니다.
(일반적으로 0~6에 익숙한 사람에겐 특이합니다.)


# 날짜계산
숫자기반으로 더하기
이 방법은 SYSTIMESTAMP 에서 사용할 수 없습니다.
1이 하루이기 때문에 + 3 이라고하면 3일 이후가 나옵니다.
시간이라고하면 (1/24*7)하면 7시간 : 하루 / 24[분] * 원하는시간
마찬가지로 분이라고하면 (1/24/60*17) 17분
외우기는 간단하지만 상당히 생소한 방법입니다.
``` java
SELECT
	to_char(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') AS 오늘SD,
	to_char(SYSDATE + 3, 'YYYY-MM-DD HH24:MI:SS') AS 연산SD3일, -- 3일더함
	to_char(SYSDATE + 3 + (1/24*5), 'YYYY-MM-DD HH24:MI:SS') AS 연산SD2일5시간 -- 2일 5시간 더함
FROM DUAL
```
INTERVAL 로 더하기
옵션으로 YEAR, MONTH, DAY, HOUR, MINUTE, SECOND 옵션을 사용할 수 있습니다.
또한 DAY TO SECOND 같은 TO 옵션도 사용할 수 있습니다.
``` java
SELECT
	-- SYSDATE
	to_char(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') AS 오늘SD,
	-- 3일 20시간 11분 22초를 이후
	to_char(SYSDATE + INTERVAL '3 20:11:22' DAY TO SECOND, 'YYYY-MM-DD HH24:MI:SS') AS 연산SD1,
	-- 3시간 이전
	to_char(SYSDATE - INTERVAL '3' HOUR, 'YYYY-MM-DD HH24:MI:SS') AS 연산SD2,
	-- SYSTIMESTAMP
	to_char(SYSTIMESTAMP, 'YYYY-MM-DD HH24:MI:SS') AS 오늘ST,
	-- 32 분 이후
	to_char(SYSTIMESTAMP + INTERVAL '32' MINUTE, 'YYYY-MM-DD HH24:MI:SS') AS 연산ST1,
	-- 99일 이후 (DAY의 MAX 가 99 입니다.)
	to_char(SYSTIMESTAMP + INTERVAL '99' DAY, 'YYYY-MM-DD HH24:MI:SS') AS 연산ST2
FROM DUAL
```
불행이도 숫자기반보다 조금 위험한 점이있습니다.
예를들어 DAY의 경우 99 이상의 값을 넣을 수 없습니다.
즉 DAY를 더해주는 단순연산이라면 오히려 위 숫자방법이 나을 수 있습니다.
비교
``` java
SELECT
  -- 3시간 이후 값에서 현재값을 제거
  -- 0.125일 차이
	(SYSDATE + INTERVAL '3' HOUR) - SYSDATE
FROM DUAL
```